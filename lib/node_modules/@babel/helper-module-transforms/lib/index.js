"use strict";

require("core-js/modules/es.array.reduce.js");
require("core-js/modules/es.array.sort.js");
require("core-js/modules/esnext.iterator.constructor.js");
require("core-js/modules/esnext.iterator.for-each.js");
require("core-js/modules/esnext.iterator.reduce.js");
require("core-js/modules/esnext.iterator.some.js");
require("core-js/modules/web.dom-collections.iterator.js");
var _templateObject, _templateObject2, _templateObject3, _templateObject4, _templateObject5, _templateObject6, _templateObject7, _templateObject8, _templateObject9, _templateObject10, _templateObject11, _templateObject12, _templateObject13, _templateObject14;
function _taggedTemplateLiteral(e, t) { return t || (t = e.slice(0)), Object.freeze(Object.defineProperties(e, { raw: { value: Object.freeze(t) } })); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "buildDynamicImport", {
  enumerable: true,
  get: function get() {
    return _dynamicImport.buildDynamicImport;
  }
});
exports.buildNamespaceInitStatements = buildNamespaceInitStatements;
exports.ensureStatementsHoisted = ensureStatementsHoisted;
Object.defineProperty(exports, "getModuleName", {
  enumerable: true,
  get: function get() {
    return _getModuleName.default;
  }
});
Object.defineProperty(exports, "hasExports", {
  enumerable: true,
  get: function get() {
    return _normalizeAndLoadMetadata.hasExports;
  }
});
Object.defineProperty(exports, "isModule", {
  enumerable: true,
  get: function get() {
    return _helperModuleImports.isModule;
  }
});
Object.defineProperty(exports, "isSideEffectImport", {
  enumerable: true,
  get: function get() {
    return _normalizeAndLoadMetadata.isSideEffectImport;
  }
});
exports.rewriteModuleStatementsAndPrepareHeader = rewriteModuleStatementsAndPrepareHeader;
Object.defineProperty(exports, "rewriteThis", {
  enumerable: true,
  get: function get() {
    return _rewriteThis.default;
  }
});
exports.wrapInterop = wrapInterop;
var _assert = require("assert");
var _core = require("@babel/core");
var _helperModuleImports = require("@babel/helper-module-imports");
var _rewriteThis = require("./rewrite-this.js");
var _rewriteLiveReferences = require("./rewrite-live-references.js");
var _normalizeAndLoadMetadata = require("./normalize-and-load-metadata.js");
var Lazy = require("./lazy-modules.js");
var _dynamicImport = require("./dynamic-import.js");
var _getModuleName = require("./get-module-name.js");
{
  exports.getDynamicImportSource = require("./dynamic-import").getDynamicImportSource;
}
function rewriteModuleStatementsAndPrepareHeader(path, _ref) {
  let {
    exportName,
    strict,
    allowTopLevelThis,
    strictMode,
    noInterop,
    importInterop = noInterop ? "none" : "babel",
    lazy,
    getWrapperPayload = Lazy.toGetWrapperPayload(lazy != null ? lazy : false),
    wrapReference = Lazy.wrapReference,
    esNamespaceOnly,
    filename,
    constantReexports = arguments[1].loose,
    enumerableModuleMeta = arguments[1].loose,
    noIncompleteNsImportDetection
  } = _ref;
  (0, _normalizeAndLoadMetadata.validateImportInteropOption)(importInterop);
  _assert((0, _helperModuleImports.isModule)(path), "Cannot process module statements in a script");
  path.node.sourceType = "script";
  const meta = (0, _normalizeAndLoadMetadata.default)(path, exportName, {
    importInterop,
    initializeReexports: constantReexports,
    getWrapperPayload,
    esNamespaceOnly,
    filename
  });
  if (!allowTopLevelThis) {
    (0, _rewriteThis.default)(path);
  }
  (0, _rewriteLiveReferences.default)(path, meta, wrapReference);
  if (strictMode !== false) {
    const hasStrict = path.node.directives.some(directive => {
      return directive.value.value === "use strict";
    });
    if (!hasStrict) {
      path.unshiftContainer("directives", _core.types.directive(_core.types.directiveLiteral("use strict")));
    }
  }
  const headers = [];
  if ((0, _normalizeAndLoadMetadata.hasExports)(meta) && !strict) {
    headers.push(buildESModuleHeader(meta, enumerableModuleMeta));
  }
  const nameList = buildExportNameListDeclaration(path, meta);
  if (nameList) {
    meta.exportNameListName = nameList.name;
    headers.push(nameList.statement);
  }
  headers.push(...buildExportInitializationStatements(path, meta, wrapReference, constantReexports, noIncompleteNsImportDetection));
  return {
    meta,
    headers
  };
}
function ensureStatementsHoisted(statements) {
  statements.forEach(header => {
    header._blockHoist = 3;
  });
}
function wrapInterop(programPath, expr, type) {
  if (type === "none") {
    return null;
  }
  if (type === "node-namespace") {
    return _core.types.callExpression(programPath.hub.addHelper("interopRequireWildcard"), [expr, _core.types.booleanLiteral(true)]);
  } else if (type === "node-default") {
    return null;
  }
  let helper;
  if (type === "default") {
    helper = "interopRequireDefault";
  } else if (type === "namespace") {
    helper = "interopRequireWildcard";
  } else {
    throw new Error("Unknown interop: ".concat(type));
  }
  return _core.types.callExpression(programPath.hub.addHelper(helper), [expr]);
}
function buildNamespaceInitStatements(metadata, sourceMetadata) {
  let constantReexports = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  let wrapReference = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : Lazy.wrapReference;
  var _wrapReference;
  const statements = [];
  const srcNamespaceId = _core.types.identifier(sourceMetadata.name);
  for (const localName of sourceMetadata.importsNamespace) {
    if (localName === sourceMetadata.name) continue;
    statements.push(_core.template.statement(_templateObject || (_templateObject = _taggedTemplateLiteral(["var NAME = SOURCE;"])))({
      NAME: localName,
      SOURCE: _core.types.cloneNode(srcNamespaceId)
    }));
  }
  const srcNamespace = (_wrapReference = wrapReference(srcNamespaceId, sourceMetadata.wrap)) != null ? _wrapReference : srcNamespaceId;
  if (constantReexports) {
    statements.push(...buildReexportsFromMeta(metadata, sourceMetadata, true, wrapReference));
  }
  for (const exportName of sourceMetadata.reexportNamespace) {
    statements.push((!_core.types.isIdentifier(srcNamespace) ? _core.template.statement(_templateObject2 || (_templateObject2 = _taggedTemplateLiteral(["\n            Object.defineProperty(EXPORTS, \"NAME\", {\n              enumerable: true,\n              get: function() {\n                return NAMESPACE;\n              }\n            });\n          "]))) : _core.template.statement(_templateObject3 || (_templateObject3 = _taggedTemplateLiteral(["EXPORTS.NAME = NAMESPACE;"]))))({
      EXPORTS: metadata.exportName,
      NAME: exportName,
      NAMESPACE: _core.types.cloneNode(srcNamespace)
    }));
  }
  if (sourceMetadata.reexportAll) {
    const statement = buildNamespaceReexport(metadata, _core.types.cloneNode(srcNamespace), constantReexports);
    statement.loc = sourceMetadata.reexportAll.loc;
    statements.push(statement);
  }
  return statements;
}
const ReexportTemplate = {
  constant: _ref2 => {
    let {
      exports,
      exportName,
      namespaceImport
    } = _ref2;
    return _core.template.statement.ast(_templateObject4 || (_templateObject4 = _taggedTemplateLiteral(["\n      ", ".", " = ", ";\n    "])), exports, exportName, namespaceImport);
  },
  constantComputed: _ref3 => {
    let {
      exports,
      exportName,
      namespaceImport
    } = _ref3;
    return _core.template.statement.ast(_templateObject5 || (_templateObject5 = _taggedTemplateLiteral(["\n      ", "[\"", "\"] = ", ";\n    "])), exports, exportName, namespaceImport);
  },
  spec: _ref4 => {
    let {
      exports,
      exportName,
      namespaceImport
    } = _ref4;
    return _core.template.statement.ast(_templateObject6 || (_templateObject6 = _taggedTemplateLiteral(["\n      Object.defineProperty(", ", \"", "\", {\n        enumerable: true,\n        get: function() {\n          return ", ";\n        },\n      });\n    "])), exports, exportName, namespaceImport);
  }
};
function buildReexportsFromMeta(meta, metadata, constantReexports, wrapReference) {
  var _wrapReference2;
  let namespace = _core.types.identifier(metadata.name);
  namespace = (_wrapReference2 = wrapReference(namespace, metadata.wrap)) != null ? _wrapReference2 : namespace;
  const {
    stringSpecifiers
  } = meta;
  return Array.from(metadata.reexports, _ref5 => {
    let [exportName, importName] = _ref5;
    let namespaceImport = _core.types.cloneNode(namespace);
    if (importName === "default" && metadata.interop === "node-default") {} else if (stringSpecifiers.has(importName)) {
      namespaceImport = _core.types.memberExpression(namespaceImport, _core.types.stringLiteral(importName), true);
    } else {
      namespaceImport = _core.types.memberExpression(namespaceImport, _core.types.identifier(importName));
    }
    const astNodes = {
      exports: meta.exportName,
      exportName,
      namespaceImport
    };
    if (constantReexports || _core.types.isIdentifier(namespaceImport)) {
      if (stringSpecifiers.has(exportName)) {
        return ReexportTemplate.constantComputed(astNodes);
      } else {
        return ReexportTemplate.constant(astNodes);
      }
    } else {
      return ReexportTemplate.spec(astNodes);
    }
  });
}
function buildESModuleHeader(metadata) {
  let enumerableModuleMeta = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  return (enumerableModuleMeta ? _core.template.statement(_templateObject7 || (_templateObject7 = _taggedTemplateLiteral(["\n        EXPORTS.__esModule = true;\n      "]))) : _core.template.statement(_templateObject8 || (_templateObject8 = _taggedTemplateLiteral(["\n        Object.defineProperty(EXPORTS, \"__esModule\", {\n          value: true,\n        });\n      "]))))({
    EXPORTS: metadata.exportName
  });
}
function buildNamespaceReexport(metadata, namespace, constantReexports) {
  return (constantReexports ? _core.template.statement(_templateObject9 || (_templateObject9 = _taggedTemplateLiteral(["\n        Object.keys(NAMESPACE).forEach(function(key) {\n          if (key === \"default\" || key === \"__esModule\") return;\n          VERIFY_NAME_LIST;\n          if (key in EXPORTS && EXPORTS[key] === NAMESPACE[key]) return;\n\n          EXPORTS[key] = NAMESPACE[key];\n        });\n      "]))) : _core.template.statement(_templateObject10 || (_templateObject10 = _taggedTemplateLiteral(["\n        Object.keys(NAMESPACE).forEach(function(key) {\n          if (key === \"default\" || key === \"__esModule\") return;\n          VERIFY_NAME_LIST;\n          if (key in EXPORTS && EXPORTS[key] === NAMESPACE[key]) return;\n\n          Object.defineProperty(EXPORTS, key, {\n            enumerable: true,\n            get: function() {\n              return NAMESPACE[key];\n            },\n          });\n        });\n    "]))))({
    NAMESPACE: namespace,
    EXPORTS: metadata.exportName,
    VERIFY_NAME_LIST: metadata.exportNameListName ? (0, _core.template)(_templateObject11 || (_templateObject11 = _taggedTemplateLiteral(["\n            if (Object.prototype.hasOwnProperty.call(EXPORTS_LIST, key)) return;\n          "])))({
      EXPORTS_LIST: metadata.exportNameListName
    }) : null
  });
}
function buildExportNameListDeclaration(programPath, metadata) {
  const exportedVars = Object.create(null);
  for (const data of metadata.local.values()) {
    for (const name of data.names) {
      exportedVars[name] = true;
    }
  }
  let hasReexport = false;
  for (const data of metadata.source.values()) {
    for (const exportName of data.reexports.keys()) {
      exportedVars[exportName] = true;
    }
    for (const exportName of data.reexportNamespace) {
      exportedVars[exportName] = true;
    }
    hasReexport = hasReexport || !!data.reexportAll;
  }
  if (!hasReexport || Object.keys(exportedVars).length === 0) return null;
  const name = programPath.scope.generateUidIdentifier("exportNames");
  delete exportedVars.default;
  return {
    name: name.name,
    statement: _core.types.variableDeclaration("var", [_core.types.variableDeclarator(name, _core.types.valueToNode(exportedVars))])
  };
}
function buildExportInitializationStatements(programPath, metadata, wrapReference) {
  let constantReexports = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
  let noIncompleteNsImportDetection = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
  const initStatements = [];
  for (const [localName, data] of metadata.local) {
    if (data.kind === "import") {} else if (data.kind === "hoisted") {
      initStatements.push([data.names[0], buildInitStatement(metadata, data.names, _core.types.identifier(localName))]);
    } else if (!noIncompleteNsImportDetection) {
      for (const exportName of data.names) {
        initStatements.push([exportName, null]);
      }
    }
  }
  for (const data of metadata.source.values()) {
    if (!constantReexports) {
      const reexportsStatements = buildReexportsFromMeta(metadata, data, false, wrapReference);
      const reexports = [...data.reexports.keys()];
      for (let i = 0; i < reexportsStatements.length; i++) {
        initStatements.push([reexports[i], reexportsStatements[i]]);
      }
    }
    if (!noIncompleteNsImportDetection) {
      for (const exportName of data.reexportNamespace) {
        initStatements.push([exportName, null]);
      }
    }
  }
  initStatements.sort((_ref6, _ref7) => {
    let [a] = _ref6;
    let [b] = _ref7;
    if (a < b) return -1;
    if (b < a) return 1;
    return 0;
  });
  const results = [];
  if (noIncompleteNsImportDetection) {
    for (const [, initStatement] of initStatements) {
      results.push(initStatement);
    }
  } else {
    const chunkSize = 100;
    for (let i = 0; i < initStatements.length; i += chunkSize) {
      let uninitializedExportNames = [];
      for (let j = 0; j < chunkSize && i + j < initStatements.length; j++) {
        const [exportName, initStatement] = initStatements[i + j];
        if (initStatement !== null) {
          if (uninitializedExportNames.length > 0) {
            results.push(buildInitStatement(metadata, uninitializedExportNames, programPath.scope.buildUndefinedNode()));
            uninitializedExportNames = [];
          }
          results.push(initStatement);
        } else {
          uninitializedExportNames.push(exportName);
        }
      }
      if (uninitializedExportNames.length > 0) {
        results.push(buildInitStatement(metadata, uninitializedExportNames, programPath.scope.buildUndefinedNode()));
      }
    }
  }
  return results;
}
const InitTemplate = {
  computed: _ref8 => {
    let {
      exports,
      name,
      value
    } = _ref8;
    return _core.template.expression.ast(_templateObject12 || (_templateObject12 = _taggedTemplateLiteral(["", "[\"", "\"] = ", ""])), exports, name, value);
  },
  default: _ref9 => {
    let {
      exports,
      name,
      value
    } = _ref9;
    return _core.template.expression.ast(_templateObject13 || (_templateObject13 = _taggedTemplateLiteral(["", ".", " = ", ""])), exports, name, value);
  },
  define: _ref10 => {
    let {
      exports,
      name,
      value
    } = _ref10;
    return _core.template.expression.ast(_templateObject14 || (_templateObject14 = _taggedTemplateLiteral(["\n      Object.defineProperty(", ", \"", "\", {\n        enumerable: true,\n        value: void 0,\n        writable: true\n      })[\"", "\"] = ", ""])), exports, name, name, value);
  }
};
function buildInitStatement(metadata, exportNames, initExpr) {
  const {
    stringSpecifiers,
    exportName: exports
  } = metadata;
  return _core.types.expressionStatement(exportNames.reduce((value, name) => {
    const params = {
      exports,
      name,
      value
    };
    if (name === "__proto__") {
      return InitTemplate.define(params);
    }
    if (stringSpecifiers.has(name)) {
      return InitTemplate.computed(params);
    }
    return InitTemplate.default(params);
  }, initExpr));
}